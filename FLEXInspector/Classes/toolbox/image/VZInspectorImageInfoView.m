//
//  VZInspectorImageInfoView.m
//  APInspector
//
//  Created by Sleen on 2016/12/8.
//  Copyright © 2016年 Alipay. All rights reserved.
//

#import "VZInspector.h"
#import "VZInspectorImageInfoView.h"
#import "VZDefine.h"
#import "VZInspectorResource.h"


static const u_int8_t vz_inspector_image_info_select[] = {0x89,0x50,0x4e,0x47,0xd,0xa,0x1a,0xa,0x0,0x0,0x0,0xd,0x49,0x48,0x44,0x52,0x0,0x0,0x0,0x28,0x0,0x0,0x0,0x28,0x8,0x4,0x0,0x0,0x0,0x26,0xf7,0x70,0xe6,0x0,0x0,0x1,0x80,0x49,0x44,0x41,0x54,0x78,0x1,0xdd,0xd6,0x33,0x0,0xd5,0x5d,0x1c,0x6,0xe0,0xf3,0xd9,0xb6,0xad,0x6c,0x2f,0xd9,0xb6,0x6b,0x6d,0xcd,0x36,0x96,0xec,0x5a,0xb2,0x5d,0x53,0x4b,0xb6,0x6d,0xdb,0x76,0xdd,0x27,0xdb,0xf7,0xfe,0xd3,0xf7,0x7b,0xa7,0xa3,0x67,0x3d,0x6f,0x10,0x71,0x5e,0x1d,0xf0,0x6d,0x9d,0x1d,0xf2,0xf4,0x73,0x58,0x67,0x6f,0x3f,0x8,0xec,0x24,0xfe,0x69,0xf7,0x20,0xf0,0x10,0xb2,0x9,0x4f,0x9d,0x6c,0x38,0xf4,0x20,0x10,0x42,0x5c,0xc1,0xff,0xd,0xec,0xe0,0xf5,0x68,0x41,0x86,0x7b,0x27,0x5a,0x90,0xa9,0x3e,0x8b,0x16,0x64,0xa5,0x9f,0xa3,0x4,0xb7,0x61,0xa7,0x14,0xd1,0x81,0x7f,0x98,0x8b,0x63,0x72,0x44,0x5,0x7e,0xe2,0x7d,0xe3,0x70,0x4e,0xa5,0xa8,0xc0,0xe0,0xd,0x3d,0x11,0x53,0x37,0x22,0xf0,0x5a,0x1a,0x88,0xa1,0xab,0x37,0xa2,0x2,0x83,0x2a,0xce,0x63,0x8c,0xf7,0xa2,0x2,0x83,0xdc,0x8e,0x63,0x96,0x2f,0x6e,0xac,0x9b,0x26,0xa,0x6,0xa9,0xec,0xc6,0x5a,0xbf,0xdd,0x58,0xd7,0x4e,0x14,0xc,0x7e,0xb1,0x1a,0x7b,0xa4,0xb9,0xb1,0x4e,0x18,0xc,0x3e,0x37,0x1d,0x27,0xe4,0x8b,0xa,0xc,0xde,0x35,0xa,0xe7,0x55,0x8f,0xa,0xc,0x5e,0xd7,0x19,0x31,0x8d,0x23,0x2,0xaf,0xa5,0x96,0x18,0xfa,0x7a,0x23,0x11,0xf0,0x57,0xed,0xee,0xc8,0x72,0x30,0xc9,0x7,0xf1,0x81,0x6f,0x8,0xde,0xb4,0xdb,0xfd,0x33,0xcf,0xd7,0x8f,0xff,0x46,0xef,0x5,0xb,0x9b,0x2c,0x8,0x1a,0x61,0x8f,0xba,0xf7,0xa4,0xd4,0x63,0x3f,0xfa,0x7b,0xc0,0x3a,0x2e,0x22,0x93,0xe0,0x4b,0x67,0xc4,0x24,0x79,0x5c,0x15,0x39,0xfc,0x8,0xf0,0x1d,0xfd,0x1,0x43,0x4,0xe1,0xda,0xaa,0x67,0x7c,0x65,0x9,0xfe,0x32,0xb,0x67,0xd4,0x73,0xc9,0x39,0xdf,0x9,0x52,0xe3,0x84,0x4f,0xe3,0x5,0xf7,0x60,0xb7,0x8c,0x82,0x89,0x68,0x29,0x8,0xa6,0xa3,0x56,0xbc,0x20,0x8b,0xfc,0x78,0x6d,0x95,0x17,0xfb,0xbc,0x2d,0x28,0x83,0x4d,0x5e,0x8f,0xf,0x1c,0xe9,0x83,0x1b,0xab,0xd7,0xac,0x42,0x15,0xa9,0x8c,0x3,0x45,0x9f,0x1e,0x8c,0x69,0xee,0xb5,0x3b,0xd6,0x35,0x70,0x4c,0xc,0xe7,0xf4,0xf0,0xe3,0xd3,0x83,0x65,0xef,0x59,0x7f,0xe8,0x8,0xce,0xe9,0xee,0xa7,0xa8,0x2a,0x71,0x2b,0xdd,0xfd,0xf8,0xea,0x96,0xf6,0xcb,0xf3,0xe1,0x80,0x3b,0x7d,0xd3,0x96,0x30,0x0,0x0,0x0,0x0,0x49,0x45,0x4e,0x44,0xae,0x42,0x60,0x82};

static const uint8_t vz_inspector_image_info_copy[] = {0x89,0x50,0x4e,0x47,0xd,0xa,0x1a,0xa,0x0,0x0,0x0,0xd,0x49,0x48,0x44,0x52,0x0,0x0,0x0,0x28,0x0,0x0,0x0,0x28,0x8,0x4,0x0,0x0,0x0,0x26,0xf7,0x70,0xe6,0x0,0x0,0x0,0xc6,0x49,0x44,0x41,0x54,0x78,0x1,0xed,0xd2,0x67,0x1,0xc2,0x30,0x10,0xc5,0xf1,0x48,0x88,0x94,0x4a,0xa8,0x13,0xea,0x80,0x3a,0xe8,0x39,0x41,0x2,0x75,0x40,0x1c,0x80,0x94,0x3a,0x78,0xec,0xfd,0xe,0x2e,0x83,0xcd,0xff,0xbe,0x31,0x7e,0x49,0xda,0xb8,0x4f,0xe,0x1e,0x23,0x74,0xca,0x8c,0x53,0xb8,0x39,0x6e,0x35,0x89,0x5,0x5b,0xb0,0xd2,0x49,0x8,0x56,0x39,0x12,0x23,0xf3,0xc1,0x1e,0x43,0x24,0x89,0x1a,0x2,0x51,0x41,0x41,0x45,0x48,0x73,0x4,0x74,0xce,0x48,0xda,0xc1,0xbb,0x24,0x3c,0xa6,0x96,0x77,0xa,0x12,0x7,0x83,0xed,0x9a,0xd8,0xc1,0x75,0x1,0x72,0x35,0xe1,0x9c,0x64,0xdf,0xea,0xa0,0x68,0x17,0x48,0x7b,0x5a,0x90,0x54,0x90,0xbf,0x80,0x74,0x90,0xbc,0xd3,0x5c,0x90,0x93,0xc9,0x20,0xba,0xcd,0xec,0x2f,0x56,0x9b,0x7,0x5e,0x27,0xef,0x1,0xf2,0xde,0x1,0x84,0xa0,0xa3,0x53,0xa7,0x82,0x5a,0xf2,0x4,0xf0,0xeb,0x5f,0xa,0xf9,0xdd,0xac,0xe0,0x33,0xc4,0xbe,0xbe,0x2c,0xd8,0xc3,0x97,0x78,0x86,0xa4,0xf2,0xe0,0x1f,0x1c,0x60,0xaf,0xb1,0x80,0xd,0xac,0x2d,0xe0,0x9d,0x25,0x54,0x10,0xc3,0x34,0x9c,0xfb,0x94,0x96,0xaa,0xd3,0xec,0xac,0xf1,0xe2,0xa9,0xe,0x0,0x0,0x0,0x0,0x49,0x45,0x4e,0x44,0xae,0x42,0x60,0x82};

static const uint8_t vz_inspector_image_info_share[] = {0x89,0x50,0x4e,0x47,0xd,0xa,0x1a,0xa,0x0,0x0,0x0,0xd,0x49,0x48,0x44,0x52,0x0,0x0,0x0,0x28,0x0,0x0,0x0,0x28,0x8,0x4,0x0,0x0,0x0,0x26,0xf7,0x70,0xe6,0x0,0x0,0x0,0xb5,0x49,0x44,0x41,0x54,0x78,0x1,0xed,0xd6,0x7,0x11,0x83,0x40,0x10,0x85,0xe1,0x93,0x80,0x84,0x35,0x80,0x7,0x1c,0x4,0x9,0xe7,0x4,0xa6,0xc7,0x1d,0x38,0xc0,0xc2,0x2a,0xc8,0x9f,0x5e,0xa9,0x57,0xd2,0xef,0xbd,0x19,0xa6,0xed,0x7c,0x94,0xa3,0x19,0x22,0xf7,0x4d,0x60,0xce,0x66,0xd7,0x3c,0x16,0x98,0xd1,0x1,0xd0,0x91,0xc5,0x0,0x33,0x1a,0xce,0x69,0xe6,0x49,0x7,0x6e,0x19,0xb9,0x8c,0x5b,0x9f,0xb7,0x3d,0xd2,0x11,0x6c,0x1,0xb0,0x14,0x0,0x14,0xd8,0x23,0x19,0x6,0x5a,0xcc,0x5,0x34,0x58,0xa0,0xd,0x39,0x65,0xc1,0xdc,0x81,0x6,0x71,0x3b,0xe5,0x5e,0x7b,0xa0,0xd3,0x2a,0x97,0x54,0xf,0x5d,0xf5,0xc0,0xb1,0x99,0x3e,0x88,0x65,0x28,0xe5,0x1d,0x38,0x3e,0xd3,0x7,0xa9,0xe9,0x47,0x91,0x3b,0x50,0x50,0xfa,0xa9,0xa7,0x40,0xd7,0x6b,0x98,0xc0,0x4,0x7e,0x2d,0x28,0x28,0x8a,0x4,0x80,0x7d,0xb2,0xc7,0x5,0x80,0xfd,0x26,0x30,0x81,0x9,0xac,0x1c,0x3b,0xb,0xba,0x67,0x14,0x14,0x14,0x9f,0x28,0xf2,0xf6,0x9f,0x76,0x87,0x6e,0x1,0x16,0xee,0x71,0xf1,0x7c,0xff,0x8c,0xeb,0x0,0x0,0x0,0x0,0x49,0x45,0x4e,0x44,0xae,0x42,0x60,0x82};


@interface VZInspectorHighlightLayer : CALayer

@property (nonatomic, assign) CGFloat progress;
@property (nonatomic, assign) CGRect fromRect;
@property (nonatomic, assign) CGRect toRect;

@end

@implementation VZInspectorHighlightLayer

- (instancetype)initWithLayer:(VZInspectorHighlightLayer *)layer {
    if (self = [super initWithLayer:layer]) {
        if ([layer isKindOfClass:[VZInspectorHighlightLayer class]]) {
            _fromRect = layer.fromRect;
            _toRect = layer.toRect;
        }
    }
    return self;
}

- (void)drawInContext:(CGContextRef)ctx {
    CGFloat (^mix)(CGFloat a, CGFloat b, CGFloat percentage) = ^(CGFloat a, CGFloat b, CGFloat percentage) {
        return a + (b - a) * percentage;
    };
    CGRect (^mixRect)(CGRect a, CGRect b, CGFloat percentage) = ^(CGRect a, CGRect b, CGFloat percentage) {
        CGRect r;
        r.origin.x = mix(a.origin.x, b.origin.x, percentage);
        r.origin.y = mix(a.origin.y, b.origin.y, percentage);
        r.size.width = mix(a.size.width, b.size.width, percentage);
        r.size.height = mix(a.size.height, b.size.height, percentage);
        return r;
    };
    
    UIGraphicsPushContext(ctx);
    {
        UIBezierPath *path = [UIBezierPath bezierPathWithRect:self.bounds];
        CGRect rect = mixRect(_fromRect, _toRect, _progress);
        path.usesEvenOddFillRule = YES;
        [path appendPath:[UIBezierPath bezierPathWithRect:rect]];
        [[UIColor colorWithWhite:0 alpha:0.4] set];
        [path fill];
    }
    UIGraphicsPopContext();
}

+ (BOOL)needsDisplayForKey:(NSString *)key {
    if ([key isEqualToString:@"progress"]) {
        return YES;
    }
    return [super needsDisplayForKey:key];
}

@end


#define kVZInspectorImageInfoHMargin 20
#define kVZInspectorImageInfoVMargin 20

@interface VZInspectorImageInfoView ()

@property (nonatomic, strong) UIView *headerView;
@property (nonatomic, strong) UILabel *infoLabel;
@property (nonatomic, strong) UIImageView *imageView;
@property (nonatomic, strong) VZInspectorHighlightLayer *highlightLayer;

@property (nonatomic, strong) UIView *selectedView;

@end

@implementation VZInspectorImageInfoView
{
    BOOL _selecting;
    UIColor *_originalWindowColor;
    
    UIButton *_selectSwitchButton;
    UIButton *_copyButton;
    UIButton *_shareButton;
}

- (instancetype)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {
        _imageView = [[UIImageView alloc] init];
        _imageView.clipsToBounds = NO;
        [self addSubview:_imageView];
        
        _highlightLayer = [VZInspectorHighlightLayer new];
        _highlightLayer.frame = self.bounds;
        [self.layer addSublayer:_highlightLayer];
        
        _headerView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, frame.size.width, 20)];
        _headerView.backgroundColor = [UIColor colorWithWhite:0 alpha:0.6];
        [self addSubview:_headerView];
        
        UIButton *backButton = [[UIButton alloc]initWithFrame:CGRectMake(0, 0, 20, 20)];
        backButton.backgroundColor = [UIColor clearColor];
        [backButton setTitle:@"◀" forState:UIControlStateNormal];
        [backButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
        backButton.titleLabel.font = [UIFont systemFontOfSize:16];
        [backButton addTarget:self action:@selector(pop) forControlEvents:UIControlEventTouchUpInside];
        [_headerView addSubview:backButton];
        
        _selectSwitchButton = [[UIButton alloc]initWithFrame:CGRectMake(frame.size.width - 22, 0, 20, 20)];
        _selectSwitchButton.backgroundColor = [UIColor clearColor];
        UIImage *selectImage = VZ_IMAGE(vz_inspector_image_info_select);
        selectImage = [selectImage imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];
        [_selectSwitchButton setImage:selectImage forState:UIControlStateNormal];
        _selectSwitchButton.tintColor = [UIColor whiteColor];
        [_selectSwitchButton addTarget:self action:@selector(selectSwitchTapped) forControlEvents:UIControlEventTouchUpInside];
        [_headerView addSubview:_selectSwitchButton];
        
        _copyButton = [[UIButton alloc]initWithFrame:CGRectMake(_selectSwitchButton.frame.origin.x - 25, 0, 20, 20)];
        _copyButton.backgroundColor = [UIColor clearColor];
        _copyButton.enabled = NO;
        UIImage *copyImage = VZ_IMAGE(vz_inspector_image_info_copy);
        [_copyButton setImage:copyImage forState:UIControlStateNormal];
        [_copyButton addTarget:self action:@selector(copyTapped) forControlEvents:UIControlEventTouchUpInside];
        [_headerView addSubview:_copyButton];
        
        _shareButton = [[UIButton alloc]initWithFrame:CGRectMake(_copyButton.frame.origin.x - 25, 0, 20, 20)];
        _shareButton.backgroundColor = [UIColor clearColor];
        _shareButton.enabled = NO;
        UIImage *shareImage = VZ_IMAGE(vz_inspector_image_info_share);
        [_shareButton setImage:shareImage forState:UIControlStateNormal];
        [_shareButton addTarget:self action:@selector(shareTapped) forControlEvents:UIControlEventTouchUpInside];
        [_headerView addSubview:_shareButton];
        
        _infoLabel = [[UILabel alloc] init];
        _infoLabel.font = [UIFont systemFontOfSize:13];
        _infoLabel.textColor = [UIColor whiteColor];
        _infoLabel.numberOfLines = 0;
        _infoLabel.shadowColor = [UIColor colorWithWhite:0 alpha:0.6];
        _infoLabel.shadowOffset = CGSizeMake(1, 1);
        [self addSubview:_infoLabel];
        
        UITapGestureRecognizer *g = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapped:)];
        [self addGestureRecognizer:g];
        
        [self selectSwitchTapped];
    }
    return self;
}

- (void)inspectorHide {
    self.selectedView = nil;
}

- (NSString *)infoForImageView:(UIImageView *)imageView {
    NSMutableString *info = [NSMutableString new];
    
    UIImage *image = imageView.image;
    if (image) {
        [info appendFormat:@"image size: %@ x %@ @%@x (%.3f)\n", @(image.size.width), @(image.size.height), @(image.scale), image.size.width / image.size.height];
    }
    else {
        [info appendString:@"image: null\n"];
    }
    
    [info appendFormat:@"view size: %@ x %@ @%@x (%.3f)", @(imageView.frame.size.width), @(imageView.frame.size.height), @([UIScreen mainScreen].scale), imageView.frame.size.width / imageView.frame.size.height];
    
    if (imageView.animationImages.count > 0) {
        [info appendFormat:@"\nframe count: %d", imageView.animationImages.count];
    }
    
    return info;
}

- (void)setSelectedView:(UIView *)selectedView {
    _highlightLayer.fromRect = _selectedView ? [_selectedView convertRect:_selectedView.bounds toView:self] : self.bounds;
    CGRect newRect = _highlightLayer.toRect = selectedView ? [selectedView convertRect:selectedView.bounds toView:self] : self.bounds;
    _highlightLayer.progress = 1;
    CABasicAnimation *highlightAnimation = [CABasicAnimation animationWithKeyPath:@"progress"];
    highlightAnimation.duration = 0.2;
    highlightAnimation.fromValue = @0;
    highlightAnimation.toValue = @1;
    highlightAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];
    [_highlightLayer addAnimation:highlightAnimation forKey:@""];
    
    if (selectedView) {
        UIImageView *imageView = (UIImageView *)selectedView;
        _imageView.hidden = NO;
        _imageView.image = imageView.image;
        _imageView.contentMode = [(UIImageView *)selectedView contentMode];
        _imageView.frame = newRect;
        _imageView.alpha = 0;
        [UIView animateWithDuration:0.25 animations:^{
            _imageView.alpha = 1;
        }];
        
        _infoLabel.text = [self infoForImageView:imageView];
        _infoLabel.frame = CGRectMake(0, 0, self.bounds.size.width - 2 * kVZInspectorImageInfoHMargin, 0);
        [_infoLabel sizeToFit];
        CGRect labelFrame = _infoLabel.frame;
        labelFrame.origin.x = (self.bounds.size.width - labelFrame.size.width) / 2;
        labelFrame.size.height += 2 * kVZInspectorImageInfoVMargin;
        if (newRect.origin.y < labelFrame.size.height) {
            labelFrame.origin.y = self.bounds.size.height - labelFrame.size.height;
        }
        _infoLabel.frame = labelFrame;
        
        _copyButton.enabled = YES;
        _shareButton.enabled = YES;
    }
    else {
        _infoLabel.text = nil;
        _imageView.hidden = YES;
        _copyButton.enabled = NO;
        _shareButton.enabled = NO;
    }
    
    _selectedView = selectedView;
}

- (void)willMoveToWindow:(UIWindow *)newWindow
{
    if (newWindow) {
        _originalWindowColor = newWindow.backgroundColor;
        newWindow.backgroundColor = [UIColor clearColor];
    } else {
        self.window.backgroundColor = _originalWindowColor;
        self.selectedView = nil;
    }
}

- (BOOL)canTouchPassThrough:(CGPoint)pt {
    if (_selecting) {
        return NO;
    }
    else {
        return !CGRectContainsPoint(CGRectMake(0, 0, 40, 20), pt) &&
                !CGRectContainsPoint(CGRectMake(self.frame.size.width - 40, 0, 40, 20), pt);
    }
}

- (NSArray<UIView *> *)viewsAtPoint:(CGPoint)point inView:(UIView *)rootView predicate:(BOOL(^)(UIView *view))predicate {
    NSMutableArray *views = [NSMutableArray array];
    
    NSMutableArray *viewStack = [NSMutableArray array];
    [viewStack addObject:rootView];
    
    while (viewStack.count > 0) {
        UIView *view = viewStack.lastObject;
        [viewStack removeLastObject];
        for (UIView *subview in view.subviews) {
            if (subview.hidden ||subview.alpha < 1 / 255.f) {
                continue;
            }
            if (!subview.clipsToBounds || CGRectContainsPoint(subview.bounds, [subview convertPoint:point fromView:rootView])) {
                [viewStack addObject:subview];
            }
        }
        
        if (CGRectContainsPoint(view.bounds, [view convertPoint:point fromView:rootView]) && (!predicate || predicate(view))) {
            [views addObject:view];
        }
    }
    
    return views;
}

- (void)selectSwitchTapped {
    _selecting = !_selecting;
    _selectSwitchButton.tintColor = _selecting ? VZ_INSPECTOR_MAIN_COLOR : [UIColor whiteColor];
    if (!_selecting) {
        self.selectedView = nil;
    }
}

- (void)copyTapped {
    UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];
    
    NSMutableDictionary *item = [NSMutableDictionary dictionary];
    pasteboard.image = _imageView.image;
    [item addEntriesFromDictionary:pasteboard.items.firstObject];
    pasteboard.string = _infoLabel.text ?: @"";
    [item addEntriesFromDictionary:pasteboard.items.firstObject];
    pasteboard.items = @[item];
}

- (void)shareTapped {
    NSMutableArray *items = [NSMutableArray array];
    if (_imageView.image) {
        [items addObject:_imageView.image];
    }
    [items addObject:_infoLabel.text ?: @""];
    
    UIActivityViewController *activityViewController = [[UIActivityViewController alloc] initWithActivityItems:items applicationActivities:nil];
    [self.window.rootViewController presentViewController:activityViewController animated:YES completion:^{ }];
}

- (void)tapped:(UIGestureRecognizer *)gesture {
    if (!_selecting) {
        return;
    }
    
    CGPoint point = [gesture locationInView:self];
    UIWindow *keyWindow = [UIApplication sharedApplication].keyWindow;
    NSArray *viewsAtPoint = [self viewsAtPoint:point inView:keyWindow predicate:^BOOL(UIView *view) {
        return [view isKindOfClass:[UIImageView class]];
    }];
    
    if (_selectedView && [viewsAtPoint containsObject:_selectedView]) {
        NSUInteger index = [viewsAtPoint indexOfObject:_selectedView];
        index = (index + 1) % viewsAtPoint.count;
        self.selectedView = viewsAtPoint[index];
    }
    else {
        self.selectedView = viewsAtPoint.firstObject;
    }
}

@end
